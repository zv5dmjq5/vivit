"""This script plots the results generated by ``run.py``. For every scenario (subfolder
in the results folder), it creates 6 plots:
1. Loss values over the optimization steps 
2. Distances to the argmin over the optimization steps 
3. Final loss values over multiple runs as boxplots
4. Final distance values over multiple runs as boxplots
5. Optimizationn trajectories in a 2D subspace
6. Relative dampings chosen by the directional bootstrap damping
"""

import json
import os

import numpy as np
import torch
from matplotlib import pyplot as plt

from exp.toy_problem import Quadratic
from exp.utils.plot import TikzExport


def load_dict(file_path):
    """Load dictionary from ``file_path``"""

    # Check if file exists
    try:
        file = open(file_path)
    except OSError:
        print(f"Could not read file from {file_path}\nReturn None")
        return None

    # Load file
    with file as json_file:
        return json.load(json_file)


def load_results(scenario_name, optimizer_name, run):
    """Load results from json file"""

    # Determine folder
    HERE = os.path.abspath(__file__)
    HERE_DIR = os.path.dirname(HERE)
    optimizer_path = os.path.join(HERE_DIR, "results", scenario_name, optimizer_name)

    # Load dictionary
    file_path = os.path.join(optimizer_path, f"run_{run}.json")
    results_dict = load_dict(file_path)
    return np.array(results_dict["trajectory"]), np.array(results_dict["f_vals"])


def load_dampings(scenario_name, run):
    """Load dampings chosen by BDN"""

    # Determine folder
    HERE = os.path.abspath(__file__)
    HERE_DIR = os.path.dirname(HERE)
    optimizer_path = os.path.join(HERE_DIR, "results", scenario_name, "BDN")

    # Load dictionary
    file_path = os.path.join(optimizer_path, f"run_{run}.json")
    results_dict = load_dict(file_path)
    return np.array(results_dict["dampings"])


def load_scenario(scenario_name):
    """Load scenario info from json file"""

    # Determine folder
    HERE = os.path.abspath(__file__)
    HERE_DIR = os.path.dirname(HERE)
    scenario_path = os.path.join(HERE_DIR, "results", scenario_name)

    # Load dictionary
    file_path = os.path.join(scenario_path, "scenario_info.json")
    return load_dict(file_path)


def plot_func(ax, func, x_range, y_range, n_1=100, n_2=100):
    """Plot evaluations of function ``func`` over the 2D grid specified by ``x_range``,
    ``y_range``, ``n_1`` and ``n_2`` as a contourf plot. The function func needs to map
    from a 1d tensor to a 1d scalar tensor
    """

    # Compute 2D grid
    x = torch.linspace(x_range[0], x_range[1], n_1)
    y = torch.linspace(y_range[0], y_range[1], n_2)
    X, Y = torch.meshgrid(x, y)

    # Evaluate func
    Func_vals = torch.zeros(n_1, n_2)
    for i in range(n_1):
        for j in range(n_2):
            xy = torch.Tensor([x[i], y[j]]).reshape(2)
            Func_vals[i, j] = func(xy)

    # Contour plot
    return ax.contourf(X, Y, Func_vals, levels=10, cmap="Greys")


def plot_trajectory(ax, trajectory, color, label=None, alpha=1.0):
    """Plot the trajactory (2 x n torch.Tensor)."""
    ax.plot(
        trajectory[0, :],
        trajectory[1, :],
        "-o",
        color=color,
        label=label,
        ms=3,
        alpha=alpha,
    )


def plot_loss_dist(ax, loss_dist, color, label=None, alpha=1.0):
    """Plot the losses or distances."""
    ax.plot(
        torch.arange(len(loss_dist)),
        loss_dist,
        "-",
        color=color,
        label=label,
        ms=3,
        alpha=alpha,
    )


def get_color(optimizer_name):
    """Determine color based on ``optimizer_name``"""

    # SGD
    if "SGD" in optimizer_name:
        return "#8c8c8c"  # Grey

    # Bootstrap Damping
    elif "BDN" in optimizer_name:
        return "#bf3f3f"  # Red

    # Constant Damping
    elif "CDN" in optimizer_name:

        # Extract damping from ``optimizer_name``, turn it into a number ``rel_col``
        # between 0 (lowest damping) and 1 (highest damping in ``CDN_DAMPINGS``)
        cdn_dampings = torch.Tensor(CDN_DAMPINGS)
        min_log_damping = torch.log10(cdn_dampings[0])
        max_log_damping = torch.log10(cdn_dampings[-1])
        damping = float(optimizer_name.split("CDN_")[1])
        log_damping = torch.log10(torch.Tensor([damping]))
        rel_col = (log_damping - min_log_damping) / (max_log_damping - min_log_damping)

        # Determine color based on rel_col
        cmap = plt.get_cmap("viridis")
        return cmap(rel_col.item())
    else:
        print(f"Could not determine color for {optimizer_name}\nReturn black")
        return "k"


def save_fig(fig, fig_name):
    """Save figure to corresponding folder"""

    # Determine folder
    HERE = os.path.abspath(__file__)
    HERE_DIR = os.path.dirname(HERE)
    fig_path = os.path.join(HERE_DIR, "results", scenario_name)

    # Save as pdf and tikz
    fig.savefig(os.path.join(fig_path, fig_name + ".pdf"))
    TikzExport().save_fig(os.path.join(fig_path, fig_name), tex_preview=False)


def set_bp_color(boxplot, color):
    """Set color of boxplot ``boxplot``"""
    for item in ["boxes", "whiskers", "fliers", "medians", "caps"]:
        plt.setp(boxplot[item], color=color)


if __name__ == "__main__":  # noqa: C901

    # Find all scenarios
    HERE = os.path.abspath(__file__)
    HERE_DIR = os.path.dirname(HERE)
    RESULTS_DIR = os.path.join(HERE_DIR, "results")

    # Choose scenarios (manually or use all scenarios in results folder)
    # SCENARIO_NAMES = ["gradient_and_curvature_noise"]
    SCENARIO_NAMES = next(os.walk(RESULTS_DIR))[1]
    print(f"Visualization for scenarios {SCENARIO_NAMES}")

    # Visualization parameters
    LOSS_LINTHRESH = 1e-1  # Linear threshold for symlog plot
    DIST_LINTHRESH = 1e-1  # Linear threshold for symlog plot
    ALPHA = 0.3
    FIGSIZE = (5, 5)
    PLOT_RUNS = 0  # Plot individual runs (loss and distance over optimization steps)
    PLOT_TRAJECTORIES = 3  # # Plot individual trajectories

    for scenario_name in SCENARIO_NAMES:
        print(f"   Visualization for scenario '{scenario_name}'")

        # Extract some important parameters
        scenario_dict = load_scenario(scenario_name)
        NOF_RUNS = scenario_dict["NOF_RUNS"]
        NOF_STEPS = scenario_dict["NOF_STEPS"]
        CDN_DAMPINGS = scenario_dict["CDN_DAMPINGS"]
        DAMPING_GRID = np.array(scenario_dict["BDN_DAMPING_GRID"])
        ARGMIN = np.array(scenario_dict["ARGMIN"])
        F_A = torch.Tensor(scenario_dict["F_A"])
        F_B = torch.Tensor(scenario_dict["F_B"])
        F_C = torch.Tensor(scenario_dict["F_C"])
        D = len(F_B)

        # List of optimizers
        OPTIMIZER_NAMES = ["SGD", "BDN"]
        for damping in CDN_DAMPINGS:
            OPTIMIZER_NAMES.append(f"CDN_{damping:.1e}")

        # Construct labels
        LABELS = ["SGD", r"$\delta_k$ (ours)"]
        for damping in CDN_DAMPINGS:
            exponent_str = f"{damping:.0e}"
            split_str = exponent_str.split("e")
            if split_str[0] == "1":
                split_str[0] = ""
            split_str[1] = "{" + f"{int(split_str[1])}" + "}"
            damping_str = rf"{split_str[0]} 10^{split_str[1]}"
            LABELS.append(rf"$\delta = {damping_str}$")

        # Subspace indices for plotting the trajectories
        SUBSPACE_INDEX_1 = 0
        SUBSPACE_INDEX_2 = D - 1

        # ---------------------------------
        # Loss
        # ---------------------------------

        fig, ax = plt.subplots(1, 1, figsize=FIGSIZE)
        ax.axhline(scenario_dict["LOSS_INIT"], color="k", ls="-")
        ax.axhline(LOSS_LINTHRESH, color="k", ls="--")

        # Choose and plot optimizers
        # plot_optimizers = OPTIMIZER_NAMES
        plot_optimizers = ["BDN", "CDN_1.0e-04", "CDN_1.0e+00", "CDN_1.0e+02"]
        for opt_idx, opt_name in enumerate(OPTIMIZER_NAMES):
            if opt_name not in plot_optimizers:
                continue

            # Collect results over all runs
            results = np.zeros((NOF_RUNS, NOF_STEPS + 1))
            for run in range(NOF_RUNS):
                _, f_vals = load_results(scenario_name, opt_name, run)
                results[run, :] = f_vals

            # Compute quantiles, median, mean
            q_lower = np.quantile(results, q=0.25, axis=0)
            q_upper = np.quantile(results, q=0.75, axis=0)
            q_50 = np.quantile(results, q=0.50, axis=0)
            mean = np.mean(results, axis=0)

            # Plot quantiles, median, mean
            col = get_color(opt_name)
            x = np.arange(NOF_STEPS + 1)
            ax.fill_between(x, q_lower, q_upper, color=col, alpha=0.1)
            ax.plot(x, q_50, color=col, label=LABELS[opt_idx])
            ax.plot(x, mean, color=col, ls="--")

            # Plot the first PLOT_RUNS individual runs
            for run in range(min(PLOT_RUNS, NOF_RUNS)):
                plot_loss_dist(
                    ax, results[run, :] - scenario_dict["MIN"], col, None, alpha=ALPHA
                )

        # General settings
        ax.legend(ncol=2, loc="upper center", bbox_to_anchor=(0.5, 0.95))
        ax.set_title("Loss")
        ax.set_yscale("symlog", linthresh=LOSS_LINTHRESH)
        # ax.set_yscale("log")
        ax.set_ylabel(r"$\mathcal{L}(\theta) - \mathcal{L}({\theta_{min}})$")
        ax.set_xlabel("step")
        ax.set_xticks(np.arange(0, NOF_STEPS + 1, 5))
        ax.grid()
        fig.tight_layout()
        save_fig(fig, "Loss")

        # ---------------------------------
        # Distance
        # ---------------------------------

        fig, ax = plt.subplots(1, 1, figsize=FIGSIZE)
        ax.axhline(scenario_dict["DIST_INIT"], color="k", ls="-")
        ax.axhline(DIST_LINTHRESH, color="k", ls="--")

        # Choose and plot optimizers
        # plot_optimizers = OPTIMIZER_NAMES
        plot_optimizers = ["BDN", "CDN_1.0e-04", "CDN_1.0e+00", "CDN_1.0e+02"]
        for opt_idx, opt_name in enumerate(OPTIMIZER_NAMES):
            if opt_name not in plot_optimizers:
                continue

            # Collect results over all runs
            results = np.zeros((NOF_RUNS, NOF_STEPS + 1))
            for run in range(NOF_RUNS):
                trajectory, _ = load_results(scenario_name, opt_name, run)
                results[run, :] = np.linalg.norm(
                    trajectory - ARGMIN.reshape(-1, 1), axis=0
                )

            # Compute quantiles, median, mean
            q_lower = np.quantile(results, q=0.25, axis=0)
            q_upper = np.quantile(results, q=0.75, axis=0)
            q_50 = np.quantile(results, q=0.50, axis=0)
            mean = np.mean(results, axis=0)

            # Plot quantiles, median, mean
            col = get_color(opt_name)
            x = np.arange(NOF_STEPS + 1)
            ax.fill_between(x, q_lower, q_upper, color=col, alpha=0.3)
            ax.plot(x, q_50, color=col, label=LABELS[opt_idx])
            ax.plot(x, mean, color=col, ls="--")

            # Plot the first PLOT_RUNS individual runs
            for run in range(min(PLOT_RUNS, NOF_RUNS)):
                plot_loss_dist(ax, results[run, :], col, None, alpha=ALPHA)

        # General settings
        ax.legend(ncol=2, loc="upper center", bbox_to_anchor=(0.5, 0.95))
        ax.set_title("Distance")
        ax.set_yscale("symlog", linthresh=DIST_LINTHRESH)
        # ax.set_yscale("log")
        ax.set_ylabel(r"$\Vert \theta - \theta_{min} \Vert$")
        ax.set_xlabel("step")
        ax.set_xticks(np.arange(0, NOF_STEPS + 1, 5))
        ax.grid()
        fig.tight_layout()
        save_fig(fig, "Distance")

        # ---------------------------------
        # Loss values at the end
        # ---------------------------------

        fig, ax = plt.subplots(1, 1, figsize=FIGSIZE)
        ax.axhline(scenario_dict["LOSS_INIT"], color="k", ls="-")
        ax.axhline(LOSS_LINTHRESH, color="k", ls="--")
        for opt_idx, opt_name in enumerate(OPTIMIZER_NAMES):

            # Collect results over all runs
            all_final_f_vals = np.zeros(NOF_RUNS)
            for run in range(NOF_RUNS):
                _, f_vals = load_results(scenario_name, opt_name, run)
                all_final_f_vals[run] = f_vals[-1]

            # Create boxplot
            bp = ax.boxplot(
                all_final_f_vals, positions=[opt_idx], widths=0.5, whis=[0, 100]
            )
            col = get_color(opt_name)
            set_bp_color(bp, col)

        # General settings
        ax.set_title(f"Loss after {NOF_STEPS} steps")
        ax.set_xlabel(" ")
        ax.set_xticks(list(range(len(OPTIMIZER_NAMES))))
        ax.set_xticklabels(LABELS, rotation=90)
        ax.set_yscale("symlog", linthresh=LOSS_LINTHRESH)
        # ax.set_yscale("log")
        ax.set_ylabel(r"$\mathcal{L}(\theta) - \mathcal{L}(\theta_{min})$")
        ax.yaxis.grid()
        ax.relim()
        ax.autoscale_view()
        fig.tight_layout()
        save_fig(fig, "Loss_at_end")

        # ---------------------------------
        # Distance values at the end
        # ---------------------------------

        fig, ax = plt.subplots(1, 1, figsize=FIGSIZE)
        ax.axhline(scenario_dict["DIST_INIT"], color="k", ls="-")
        ax.axhline(DIST_LINTHRESH, color="k", ls="--")
        for opt_idx, opt_name in enumerate(OPTIMIZER_NAMES):

            # Collect results over all runs
            all_final_dists = np.zeros(NOF_RUNS)
            for run in range(NOF_RUNS):
                trajectory, _ = load_results(scenario_name, opt_name, run)
                dist = np.linalg.norm(trajectory - ARGMIN.reshape(-1, 1), axis=0)
                all_final_dists[run] = dist[-1]

            # Create boxplot
            bp = ax.boxplot(
                all_final_dists, positions=[opt_idx], widths=0.5, whis=[0, 100]
            )
            col = get_color(opt_name)
            set_bp_color(bp, col)

        # General settings
        ax.set_title(f"Distance after {NOF_STEPS} steps")
        ax.set_xlabel(" ")
        ax.set_xticks(list(range(len(OPTIMIZER_NAMES))))
        ax.set_xticklabels(LABELS, rotation=90)
        ax.set_yscale("log")
        ax.set_ylabel(r"$\Vert \theta - \theta_{min} \Vert$")
        ax.yaxis.grid()
        ax.relim()
        ax.autoscale_view()
        fig.tight_layout()
        save_fig(fig, "Distance_at_end")

        # ---------------------------------
        # Trajectories in 2D Subspace
        # ---------------------------------

        fig, ax = plt.subplots(1, 1, figsize=FIGSIZE)

        # Unit vectors
        e_1 = torch.zeros(D)
        e_2 = torch.zeros(D)
        e_1[SUBSPACE_INDEX_1] = 1.0
        e_2[SUBSPACE_INDEX_2] = 1.0

        # Problem in this subspace
        F = Quadratic(F_A, F_B, F_C)

        def f_subspace(theta_2D):
            theta = theta_2D[0] * e_1 + theta_2D[1] * e_2
            return F.func(theta).item()

        # Objective function
        theta_subspace_1_range = [-20, 110]
        theta_subspace_2_range = [-20, 110]
        C = plot_func(
            ax,
            f_subspace,
            x_range=theta_subspace_1_range,
            y_range=theta_subspace_2_range,
        )
        cbar = fig.colorbar(C)

        # Argmin
        ax.plot(ARGMIN[SUBSPACE_INDEX_1], ARGMIN[SUBSPACE_INDEX_2], "r*", ms=7)

        # Choose and plot optimizers
        # plot_optimizers = OPTIMIZER_NAMES
        plot_optimizers = ["BDN", "CDN_1.0e-04", "CDN_1.0e+00", "CDN_1.0e+02"]
        for opt_idx, opt_name in enumerate(OPTIMIZER_NAMES):
            if opt_name not in plot_optimizers:
                continue

            col = get_color(opt_name)

            for run in range(min(PLOT_TRAJECTORIES, NOF_RUNS)):
                label = LABELS[opt_idx] if run == 0 else None
                trajectory, _ = load_results(scenario_name, opt_name, run)
                trajectroy = trajectory[[SUBSPACE_INDEX_1, SUBSPACE_INDEX_2], :]
                plot_trajectory(ax, trajectroy, col, label=label)

        # General settings
        ax.set_xlabel(rf"$\theta_{SUBSPACE_INDEX_1}$")
        ax.set_ylabel(rf"$\theta_{SUBSPACE_INDEX_2}$")
        ax.set_xlim(theta_subspace_1_range)
        ax.set_ylim(theta_subspace_2_range)

        x_linthresh = 1.0
        ax.set_xscale("symlog", linthresh=x_linthresh)
        ax.axvline(x_linthresh, ls="--", color="k", lw=0.75)
        ax.axvline(-x_linthresh, ls="--", color="k", lw=0.75)

        y_linthresh = 0.001
        ax.set_yscale("symlog", linthresh=y_linthresh)
        ax.axhline(y_linthresh, ls="--", color="k", lw=0.75)
        ax.axhline(-y_linthresh, ls="--", color="k", lw=0.75)

        ax.legend(ncol=3, bbox_to_anchor=(0.5, -0.4), loc="lower center")
        subspace_str = f"(subspace indices = {SUBSPACE_INDEX_1} and {SUBSPACE_INDEX_2})"
        ax.set_title(f"Optimizer Subspace Trajectories\n{subspace_str}")
        fig.tight_layout()
        save_fig(fig, "Trajectories")

        # ---------------------------------
        # Relative Dampings
        # ---------------------------------

        RUN_IDX = 0
        optimizer_name = "BDN"

        fig, ax = plt.subplots(1, 1, figsize=FIGSIZE)

        # Choose colors
        min_lambda = F_A.min().item()
        max_lambda = F_A.max().item()
        cmap = plt.get_cmap("YlOrRd")

        # Load and plot dampings
        dampings = load_dampings(scenario_name, RUN_IDX)
        x = np.arange(NOF_STEPS + 1)
        for D_idx in range(D):

            # Determine color based on curvature
            rel_col = (F_A[D_idx, D_idx].item() - min_lambda) / (
                max_lambda - min_lambda
            )
            shift = 0.1
            rel_col = (1 - shift) * rel_col + shift

            # True curvature
            true_lambda_k = F_A[D_idx, D_idx].item()

            # Plot relative damping
            ax.plot(
                x,
                dampings[D_idx, :] / true_lambda_k,
                "o",
                color=cmap(rel_col),
                alpha=0.7,
            )

        # General settings
        ax.set_title(fr"Relative directional dampings $\delta_k$ in run {RUN_IDX}")
        ax.set_yscale("log")
        ax.set_ylabel(r"$\frac{\delta_k}{k^2}$")
        ax.set_xlabel("step")
        ax.set_xticks(np.arange(0, NOF_STEPS + 1, 5))
        ax.grid()
        fig.tight_layout()
        save_fig(fig, "Dampings")
